function randomPos(){
  const {w,h} = rect();
  const s = Math.max(1, cfg.size|0);
  const p = clamp(cfg.pad|0, 0, 240);

  const forbid = getForbiddenRects();
  const candidateRect = (pt)=>({x:pt.x,y:pt.y,w:s,h:s});

  // ✅ Сетка 4x3
  const cols = 4, rows = 3;
  const cellW = w / cols;
  const cellH = h / rows;

  const cellUse = new Array(cols*rows).fill(0);
  for(const pt of history){
    const cx = Math.min(cols-1, Math.max(0, Math.floor(pt.x / cellW)));
    const cy = Math.min(rows-1, Math.max(0, Math.floor(pt.y / cellH)));
    cellUse[cy*cols + cx]++;
  }

  const order = [...cellUse.keys()].sort((a,b)=>cellUse[a]-cellUse[b]);

  function tryInCell(idx, tries){
    const cx = idx % cols;
    const cy = Math.floor(idx / cols);

    const minX = Math.max(p, cx*cellW + p);
    const maxX = Math.min(w - p - s, (cx+1)*cellW - p - s);
    const minY = Math.max(p, cy*cellH + p);
    const maxY = Math.min(h - p - s, (cy+1)*cellH - p - s);

    if(maxX <= minX || maxY <= minY) return null;

    let best=null, bestScore=-1;
    for(let i=0;i<tries;i++){
      const pt = {
        x: minX + Math.random()*(maxX-minX),
        y: minY + Math.random()*(maxY-minY),
      };
      const cr = candidateRect(pt);
      if(forbid.some(fr => intersects(cr, fr))) continue;

      const dHist = distanceToHistory(pt);
      const dLast = (last.x===null) ? dHist : Math.hypot(pt.x-last.x, pt.y-last.y);
      const score = dHist*1.0 + dLast*0.35 + Math.random()*10;

      if(score > bestScore){ bestScore=score; best=pt; }
    }
    return best;
  }

  let best = null;
  for(const idx of order){
    best = tryInCell(idx, 45);
    if(best) break;
  }

  if(!best){
    const minX = p, minY = p;
    const maxX = Math.max(minX, w - p - s);
    const maxY = Math.max(minY, h - p - s);
    for(let k=0;k<120;k++){
      const pt = { x:minX+Math.random()*(maxX-minX), y:minY+Math.random()*(maxY-minY) };
      const cr = candidateRect(pt);
      if(!forbid.some(fr => intersects(cr, fr))){
        best = pt; break;
      }
    }
    if(!best) best = {x:minX,y:minY};
  }

  last = best;
  pushHistory(best);
  return best;
}
