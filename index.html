<div id="FX_ROOT">
  <style>
    #FX_ROOT{position:relative;width:100%;height:100%;overflow:hidden;background:transparent;font-family:system-ui,-apple-system,Segoe UI,Roboto;}
    #FX_ROOT .topBanner{position:absolute;top:14px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:8px 14px;font-size:14px;color:rgba(255,255,255,.92);box-shadow:0 10px 30px rgba(0,0,0,.25);pointer-events:none;max-width:min(720px, calc(100% - 180px));text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;z-index:5;}
    #FX_ROOT .hud{position:absolute;top:14px;right:14px;display:flex;gap:10px;align-items:center;z-index:6;}
    #FX_ROOT .lamp{width:38px;height:38px;border-radius:50%;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.14);display:grid;place-items:center;cursor:pointer;user-select:none;box-shadow:0 10px 30px rgba(0,0,0,.25);}
    #FX_ROOT .count{background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:999px;font-size:13px;color:rgba(255,255,255,.92);min-width:52px;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,.25);}
    #FX_ROOT .sprite{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);cursor:pointer;user-select:none;-webkit-user-drag:none;will-change:transform,opacity,filter;z-index:4;}

    #FX_ROOT .anim-none{opacity:1;}
    #FX_ROOT .anim-pop{animation:popIn var(--dur) ease-out both;}
    @keyframes popIn{from{transform:translate(-50%,-50%) scale(.6);opacity:0;}to{transform:translate(-50%,-50%) scale(1);opacity:1;}}
    #FX_ROOT .anim-fade{animation:fadeIn var(--dur) ease-out both;}
    @keyframes fadeIn{from{opacity:0;}to{opacity:1;}}
    #FX_ROOT .anim-soft{animation:softIn var(--dur) ease-out both;}
    @keyframes softIn{from{opacity:0;filter:blur(6px);}to{opacity:1;filter:blur(0);}}
    #FX_ROOT .pulseHint{animation:pulse 700ms ease-in-out 0s 3;}
    @keyframes pulse{0%,100%{transform:translate(-50%,-50%) scale(1);}50%{transform:translate(-50%,-50%) scale(1.15);}}
  </style>

  <div class="topBanner" id="fx_banner"></div>
  <div class="hud">
    <div class="lamp" id="fx_lamp" title="–ü–æ–¥—Å–∫–∞–∑–∫–∞">üí°</div>
    <div class="count" id="fx_count"></div>
  </div>
  <img class="sprite" id="fx_sprite" alt="sprite" />

  <script>
  (function(){
    const root = document.getElementById('FX_ROOT');
    const banner = document.getElementById('fx_banner');
    const count  = document.getElementById('fx_count');
    const lamp   = document.getElementById('fx_lamp');
    const sprite = document.getElementById('fx_sprite');

    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

    // ‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò (–º–æ–∂–µ—à—å –º–µ–Ω—è—Ç—å –ø—Ä—è–º–æ —Ç—É—Ç)
    const cfg = {
      imgUrl: "", // –µ—Å–ª–∏ –ø—É—Å—Ç–æ ‚Äî –±–µ—Ä—ë–º defaultUrl
      defaultUrl: "https://propodgotovkaa-creator.github.io/babochka_2/babushka_2",
      size: 46,
      rounds: 7,
      pad: 12,
      pause: 200,
      anim: "soft",   // soft | fade | pop | none
      dur: 1100,
      task: "–ù–∞–π–¥–∏ –±–∞–±–æ—á–∫—É –∏ –Ω–∞–∂–º–∏ –Ω–∞ –Ω–µ—ë!",
      endText: "–ú–æ–ª–æ–¥–µ—Ü! –ü—Ä–∏—Ö–æ–¥–∏ –∏–≥—Ä–∞—Ç—å –µ—â—ë —Ä–∞–∑ üòä",
      arrowW: 120,
      arrowH: 220,
      logoW: 170,
      logoH: 120
    };

    let found = 0;
    let history = [];
    const HISTORY_MAX = 14;

    // —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∫–ª–µ—Ç–∫–∞–º (—á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –∫–∞—á–µ–ª–µ–π 2 —É–≥–ª–∞)
    let cellCounts = new Map();
    let lastCellKey = null;

    function rectWH(){ const r = root.getBoundingClientRect(); return {w:Math.max(1,r.width),h:Math.max(1,r.height)}; }
    function intersects(a,b){ return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h); }
    function padRect(r,p){ return {x:r.x-p,y:r.y-p,w:r.w+p*2,h:r.h+p*2}; }

    function buildForbiddenRects(){
      const {w,h} = rectWH();
      const p = clamp(cfg.pad||0, 0, 240);

      const bannerH=92;
      const bannerW=Math.min(760, w-220);
      const bannerX=(w-bannerW)/2;

      const logoX=0, logoY=h-(cfg.logoH||120);

      const aw=clamp(cfg.arrowW||120,60,220);
      const ah=clamp(cfg.arrowH||220,120,360);
      const arrowY=(h-ah)/2;

      const hudW=120, hudH=70, hudX=w-hudW, hudY=0;

      return [
        padRect({x:bannerX,y:0,w:bannerW,h:bannerH}, p),
        padRect({x:logoX,y:logoY,w:(cfg.logoW||170),h:(cfg.logoH||120)}, p),
        padRect({x:0,y:arrowY,w:aw,h:ah}, p),
        padRect({x:w-aw,y:arrowY,w:aw,h:ah}, p),
        padRect({x:hudX,y:hudY,w:hudW,h:hudH}, p),
      ];
    }

    function pushHistory(pt){ history.unshift(pt); if(history.length>HISTORY_MAX) history.pop(); }

    // ‚úÖ FIX: –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–µ–ø–µ—Ä—å —Å—á–∏—Ç–∞–µ–º –∫–∞–∫ –¶–ï–ù–¢–† (–∞ –Ω–µ –∫–∞–∫ –ª–µ–≤—ã–π –≤–µ—Ä—Ö)
    function pickPosition(){
      const {w,h} = rectWH();
      const s = Math.max(10, cfg.size||46);
      const p = clamp(cfg.pad||0, 0, 240);

      const half = s/2;
      const minX = p + half;
      const minY = p + half;
      const maxX = Math.max(minX, w - p - half);
      const maxY = Math.max(minY, h - p - half);

      const forbid = buildForbiddenRects();

      const cols=6, rows=5;
      const cellW=w/cols, cellH=h/rows;

      const lastPt = history[0] || null;
      const recent = history.slice(0, 6);

      const key=(cx,cy)=>cx+','+cy;
      const getCount=(k)=>cellCounts.get(k)||0;

      // —Ç–µ–ø–µ—Ä—å rect –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ ‚Äî —Ä–µ–∞–ª—å–Ω—ã–π top-left (x-half, y-half)
      function ok(cx,cy){
        const r={x:cx-half, y:cy-half, w:s, h:s};
        for(const f of forbid) if(intersects(r,f)) return false;
        return true;
      }

      const cells=[];
      for(let cy=0;cy<rows;cy++) for(let cx=0;cx<cols;cx++){
        const k=key(cx,cy);
        const c={x:cx*cellW+cellW/2,y:cy*cellH+cellH/2};

        const rarity = 170/(1+getCount(k));
        const dLast  = lastPt ? dist(c,lastPt) : 200;

        let dRecent=0; for(const rp of recent) dRecent += dist(c,rp);
        dRecent = recent.length ? dRecent/recent.length : 0;

        const repeatPenalty = (k===lastCellKey) ? 260 : 0;
        const score = rarity + dLast*1.05 + dRecent*0.35 + Math.random()*120 - repeatPenalty;

        cells.push({cx,cy,k,score});
      }
      cells.sort((a,b)=>b.score-a.score);

      const TOPK=Math.min(10,cells.length);
      const pool=cells.slice(0,TOPK);

      let sum=0; for(const c of pool) sum+=Math.max(1,c.score);
      let rr=Math.random()*sum;
      let chosen=pool[0];
      for(const c of pool){ rr-=Math.max(1,c.score); if(rr<=0){chosen=c;break;} }

      const cellX0=chosen.cx*cellW, cellY0=chosen.cy*cellH;

      const loX = clamp(cellX0 + p + half, minX, maxX);
      const hiX = clamp(cellX0 + cellW - p - half, minX, maxX);
      const loY = clamp(cellY0 + p + half, minY, maxY);
      const hiY = clamp(cellY0 + cellH - p - half, minY, maxY);

      const minDistFromLast = Math.max(s*1.05, 26);

      const cand=[];
      for(let i=0;i<220;i++){
        const x=loX+Math.random()*(hiX-loX);
        const y=loY+Math.random()*(hiY-loY);
        if(!ok(x,y)) continue;
        if(lastPt && dist({x,y}, lastPt) < minDistFromLast) continue;

        let dSum=0;
        for(let k=0;k<recent.length;k++) dSum += dist({x,y}, recent[k])*(k===0?1:0.35);

        cand.push({x,y,score:dSum+Math.random()*60});
      }

      function globalFallback(){
        for(let i=0;i<1600;i++){
          const x=minX+Math.random()*(maxX-minX);
          const y=minY+Math.random()*(maxY-minY);
          if(!ok(x,y)) continue;
          if(lastPt && dist({x,y}, lastPt) < minDistFromLast) continue;
          return {x,y};
        }
        return {x:minX,y:minY};
      }

      let pt;
      if(cand.length){
        cand.sort((a,b)=>b.score-a.score);
        const top=cand.slice(0, Math.min(8,cand.length));
        const pick=top[Math.floor(Math.random()*top.length)];
        pt={x:pick.x,y:pick.y};
      }else{
        pt=globalFallback();
      }

      pushHistory(pt);
      cellCounts.set(chosen.k, getCount(chosen.k)+1);
      lastCellKey = chosen.k;

      return pt;
    }

    function applyAnim(){
      sprite.style.setProperty('--dur', Math.max(0, cfg.dur||0)+'ms');
      sprite.classList.remove('anim-none','anim-pop','anim-fade','anim-soft');
      if(cfg.anim==='none') sprite.classList.add('anim-none');
      if(cfg.anim==='pop')  sprite.classList.add('anim-pop');
      if(cfg.anim==='fade') sprite.classList.add('anim-fade');
      if(cfg.anim==='soft') sprite.classList.add('anim-soft');
    }
    function setSize(){ sprite.style.width=(cfg.size||46)+'px'; sprite.style.height=(cfg.size||46)+'px'; }
    function setTexts(){ banner.textContent=cfg.task||''; count.textContent=found+'/'+(cfg.rounds||7); }

    async function tryLoadFetch(url){
      try{
        const bust=url+(url.includes('?')?'&':'?')+'v='+Date.now();
        const res=await fetch(bust,{cache:'no-store'});
        if(!res.ok) return null;
        const blob=await res.blob();
        if(!blob||blob.size<10) return null;
        return URL.createObjectURL(blob);
      }catch(e){ return null; }
    }

    function candidates(){
      const u=(cfg.imgUrl||'').trim();
      if(u) return [u];
      const base=(cfg.defaultUrl||'').trim();
      return [base, base+'.png', base+'.webp', base+'.jpg', base+'.svg'].filter(Boolean);
    }

    async function loadSprite(){
      if(sprite.dataset.objurl){ try{URL.revokeObjectURL(sprite.dataset.objurl);}catch(e){} sprite.dataset.objurl=''; }
      for(const u of candidates()){
        const obj=await tryLoadFetch(u);
        if(obj){ sprite.src=obj; sprite.dataset.objurl=obj; return true; }
      }
      return false;
    }

    function placeNow(){
      const pt=pickPosition();
      sprite.style.left=pt.x+'px';
      sprite.style.top =pt.y+'px';
      sprite.style.transform='translate(-50%,-50%)';
    }

    function nextRound(){
      if(found >= (cfg.rounds||7)){ banner.textContent=cfg.endText||''; sprite.style.display='none'; return; }
      sprite.style.display='';
      applyAnim(); placeNow(); setTexts();
    }

    sprite.addEventListener('click', ()=>{
      found++; sprite.style.display='none'; setTexts();
      setTimeout(nextRound, Math.max(0, cfg.pause||0));
    });

    lamp.addEventListener('click', ()=>{
      sprite.classList.remove('pulseHint'); void sprite.offsetWidth; sprite.classList.add('pulseHint');
    });

    // init
    setSize(); applyAnim(); setTexts();
    loadSprite().then(()=>{ placeNow(); setTexts(); });
    window.addEventListener('resize', ()=>{ clearTimeout(window.__fxR); window.__fxR=setTimeout(()=>placeNow(),150); });
  })();
  </script>
</div>
